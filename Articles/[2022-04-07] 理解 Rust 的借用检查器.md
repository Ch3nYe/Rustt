> 原文链接: https://blog.logrocket.com/introducing-the-rust-borrow-checker/
>
> **翻译：[Xiaobin.Liu](https://github.com/lxbwolf)**
>
> 选题：[Xiaobin.Liu](https://github.com/lxbwolf)
>
> 本文由 [Rustt](https://Rustt.org) 翻译，[StudyRust](https://studyrust.org) 荣誉推出

# 理解 Rust 的借用检查器

<img src="https://raw.githubusercontent.com/rustt-org/rustt-assets/main/20220407 Understanding the Rust borrow checker/00.webp" />



你已经听过、见过太多对 Rust 的宣传，现在是时候动手写 Rust 了！

<p><iframe loading="lazy" src="https://open.spotify.com/embed/episode/3ezDGcqiNw7ZTT5MGw1M49" width="100%" height="232" frameBorder="0" allowtransparency="true" allow="encrypted-media"></iframe></p>

于是你心潮澎湃地写了几行代码。执行 `cargo run` 命令后，对结果充满期待。在你的印象中，Rust 代码编译后就可以直接运行了。你开始编译，突然看到了下面的内容：

```bash
error[E0382]: borrow of moved value
```

看起来你遇到了可怕的借用检查器！DUANG! DUANG! DUANG!

## 借用检查器是什么？ 

借用检查器是 Rust 语言的一个重要的特性，也是 Rust 区别于其他语言的其中一个特点。它能帮助你（或强迫你）管理所有权。正如 [《Rust 编程语言》](https://doc.rust-lang.org/book/)的[第四章](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)所说的，“所有权是 Rust 最独特的功能，它使 Rust 能够在不需要垃圾回收器的情况下保证内存安全。”

所有权，借用检查器，以及垃圾回收器：这里有很多东西需要解读，所以让我们把它分解一下。在本指南中，我们来看看借用检查器为我们做了什么（以及它不允许我们做什么），它为我们提供了哪些保证，以及它与其他形式的内存管理相比有何不同。

我假设你有一些用 Python、JavaScript 和 C# 等高级语言编写代码的经验，但不一定熟悉计算机内存的工作原理。

## 垃圾回收 vs. 手动内存分配 vs. 借用检查器

让我们来简单谈一谈内存和内存管理。在大多数流行的编程语言中，你不需要考虑你的变量被存储在哪里。你只需声明这些变量，语言的运行时就会通过垃圾收回收器来处理剩下的问题。这就对程序员屏蔽了计算机内存相关的工作原理，程序员对内存的管理更加简单和统一。这是一件好事。

然而，我们需要剥开一层，来对比下这种方式与借用检查器。我们先来看看栈和堆。

### 栈和堆

你的程序可以访问两种可以存储数值的内存：栈和堆。这两种内存有许多不同之处，但对我们来说，最重要的区别是，存储在栈上的数据必须有一个已知的、固定的大小。而堆上的数据可以是任意大小的。

我所说的大小是什么意思？大小指的是需要多少字节来存储数据。广义上讲，某些数据类型 —— 如布尔、字符和整型 —— 有固定的大小。这些数据很容易被放在栈中。另一方面，有些数据类型，如字符串、列表和其他集合，可能有任意的大小。因此，它们不能用栈来存储，而只能用堆。

因为堆可以存储任意大小的数据，所以计算机需要找到一块足够大的内存来容纳我们想要存储的东西。这很耗时，而且程序不能像栈那样直接访问数据。我们可以通过一个指向数据存储位置的指针来访问数据。

指针就像它的名字一样：它指向堆上的某个内存地址，在那里可以找到你要找的数据。网络上有许多指针教程，你可以自己决定哪一个适合自己。[Jason C. McDonald 的这篇文章](https://dev.to/codemouse92/comment/28fl) 很好地解释了 C 语言指针，适合快速入门。

用这两种不同的内存存储的意义是什么？由于栈的工作方式，栈上的数据访问是非常快速和容易的，但要求数据符合某些标准。堆的速度较慢，但用途更广，因此在你不能使用栈的时候很有用。

### 垃圾回收

在有垃圾回收的语言中，你不需要考虑堆和栈的处理。栈上的数据一旦超出生命周期就会被丢弃。堆上的数据一旦不再需要，就由垃圾回收器来处理。

另一方面，在诸如 C 语言中，你需要自己管理内存。在高级语言中，你可能只需要简单地初始化一个列表，而在 C 语言中，你需要在堆上手动分配内存。当你分配完内存后，你也应该在用完后释放内存，以避免内存泄漏。但是要注意：内存只能被释放一次。

这种手动分配和释放的过程很容易出错。事实上，微软的一位代表透露，[微软 70% 的漏洞](https://thenewstack.io/microsoft-rust-is-the-industrys-best-chance-at-safe-systems-programming/)与内存有关。所以为什么要手动管理内存呢？因为程序员能更好地控制内存，并提供比垃圾回收更好的性能特征。程序不需要停下来耗费时间找出它需要清理的东西。

Rust 的所有权模型感觉像是介于两者之间的东西。通过跟踪数据在整个程序中的使用情况，并遵循一套规则，借用检查器能够确定数据需要在哪里被初始化，在哪里被释放（或者用 Rust 的术语，被丢弃）。这就像它为你自动插入内存分配和释放，给你带来垃圾回收的便利和手动管理的速度与效率。

在实践中，这意味着你在传递变量时可以做三件事中的一件。你可以移动数据本身并在这个过程中放弃所有权，创建一个数据的副本并传递给对方，或者传递一个数据的引用并保留所有权，让接收者暂时借用它。哪种方法最合适，完全取决于情况代码场景。

## 借用检查器的其他超能力：不并发，毋宁死

除了为程序员处理内存分配和释放外，借用检查器还通过它的一套共享规则来防止数据竞争（尽管不是普通的竞争条件）。

这些相同的借用规则还可以帮助你处理并发和并行代码，而不必担心内存安全问题，实现 Rust 的[无畏并发](https://doc.rust-lang.org/book/ch16-00-concurrency.html)。

## 缺点

就像生活中所有的好东西一样，Rust 的所有权系统也有它的缺点。事实上，如果不是因为一些缺点，这篇文章可能就不会存在。

借用检查器在理解和操作上是很棘手的 —— 以至于 Rust 社区的新人在与借用检查器的斗争中陷入困境是很常见的。我也耗费了大量时间在这种斗争中。

例如，在某些场景下共享数据会突然变成一个问题，尤其是当你需要并发修改数据的时候。某些在其他语言中超级容易从头开始创建的数据结构，在 Rust 中很难搞好。有一个很好的例子，可以看看[通过链表学习 Rust](https://rust-unofficial.github.io/too-many-lists/index.html) 这本书。这本书介绍了很多实现 Rust 的链表的方法，并详细介绍了作者在实现过程中遇到的所有问题。这本书信息量很大，也很有娱乐性 —— 非常值得一读。

当你掌握了借用检查器后，事情会慢慢变得简单。我非常喜欢 [Reddit 用户 dnkndnts 的解释](https://www.reddit.com/r/rust/comments/5ny09j/tips_to_not_fight_the_borrow_checker/dcf7t46/)：

> [借用检查器]遵循一些简单的规则。如果你不理解或者至少对这些规则有一些直觉，那么它的作用就像使用拼写检查器来帮助你用一种你甚至不知道的语言写作一样：它只会拒绝你所说的一切。
>
> 当你了解了借用检查器所依据的规则后，你就会发现它很有用，而不是像拼写检查器那样让人感到压抑和讨厌。

那么这些规则是什么呢？下面是关于存储在堆上的变量的两个最重要的规则，需要记住。

1. 当把一个变量（而不是一个变量的引用）传递给另一个函数时，你就放弃了所有权。之后另一个函数就成为这个变量的所有者，你不能再使用它了。
2. 当传递一个变量的引用时（借出），你可以有任意多的不可变的借用，或一个可变的借用。可变借用最多只能有一个。

## 实践

现在你对借用检查器是什么以及它是如何工作的有了一定的了解，让我们来看看它在实践中是如何影响我们的。我们将使用 `Vec<T>` 类型，它是 Rust 中的可增长列表（类似于 Python 的列表或 JavaScript 的数组）。因为它没有固定的大小，所以 `Vec` 需要在堆上分配。

这个例子只是用来解释借用的基本规则。我们将创建一个 vector，调用一个以它为入参的函数，然后尝试看看里面有什么。

注意：这个代码样本不能编译。

```rust
fn hold_my_vec<T>(_: Vec<T>) {}

fn main() {
    let v = vec![2, 3, 5, 7, 11, 13, 17];
    hold_my_vec(v);
    let element = v.get(3);

    println!("I got this element from the vector: {:?}", element);
}
```

你会看到下面的编译错误：

```bash
error[E0382]: borrow of moved value: `v`
--> src/main.rs:6:19
          |
        4 |     let v = vec![2, 3, 5, 7, 11, 13, 17];
          |         - move occurs because `v` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
        5 |     hold_my_vec(v);
          |                 - value moved here
        6 |     let element = v.get(3);
          |                   ^ value borrowed here after move
```

上面的信息告诉我们，`Vec<i32>` 没有实现 [Copy trait](https://doc.rust-lang.org/std/marker/trait.Copy.html)，因此必须被移动（或借用）。`Copy` trait 只能由可以放在栈上的数据类型来实现，由于 `Vec` 必须放在堆上，所以它不能实现 `Copy`。我们需要找到另一种方法来解决这个问题。

## 关于 `clone`

尽管 `Vec` 不能实现 `Copy` trait，但它可以（而且确实）实现 [Clone trait](https://doc.rust-lang.org/core/clone/trait.Clone.html)。在 Rust 中，`clone` 是另一种制造数据副本的方式。 `copy` 只能在栈上进行，而且性能开销很低，而 `clone` 还可以在堆上进行，可能会有很高的效能开销。

所以，如果函数取得了值的所有权，我们为什么不直接给它一个 `vector` 的 `clone` 呢？下面的代码就能正常工作。

```rust
fn hold_my_vec<T>(_: Vec<T>) {}

fn main() {
    let v = vec![2, 3, 5, 7, 11, 13, 17];
    hold_my_vec(v.clone());
    let element = v.get(3);

    println!("I got this element from the vector: {:?}", element);
}
```

然而，我们现在已经白白做了很多额外的工作。`hold_my_vec` 函数甚至没有使用这个向量做任何事情；它只是取得了它的所有权。在这种情况下，vector（`v`）非常小，所以 `clone` 它并不是什么大事。在"能跑就行"的开发阶段，这可能是最快速和最容易看到结果的方法。

然而，有一个更好的、更成文的方法来做这件事。让我们来看看。

## 引用

如前所述，我们可以不把变量交给其他函数，而是把它借给它们。要做到这一点，我们需要改变`hold_my_vec` 的签名，通过将传入参数的类型从 `Vec<T>` 改为 `&Vec<T>` 来接受一个引用。

我们还需要改变调用函数的方式，让 Rust 知道我们只是传给函数一个引用 —— 一个借用的值。这样，我们让函数借用一下 vector，但要在之后把它拿回来。

```rust
fn hold_my_vec<T>(_: &Vec<T>) {}

fn main() {
    let v = vec![2, 3, 5, 7, 11, 13, 17];
    hold_my_vec(&v);
    let element = v.get(3);

    println!("I got this element from the vector: {:?}", element);
}
```



## 总结

这只是对借用检查器的一个非常简要的概述，阐述它做了什么，以及为什么它要这样做。为了使本教程尽可能地易于消化，很多细枝末节都被省略了。

通常，随着你的程序越来越大，你会遇到更复杂的问题，需要更多的思考以及处理所有权和借用。你甚至可能因为 Rust 的借用检查器而不得不重新考虑你的程序结构。

这肯定是一段漫长的学习过程，但如果你坚持下去，你肯定会在这一路上学到一些关于内存的知识。


