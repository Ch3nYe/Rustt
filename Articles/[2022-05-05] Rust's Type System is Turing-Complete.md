pr前请阅读本文第一章节，确保语法通顺，表意清楚且正确

# Rust's Type System is Turing-Complete

*（注意：“fuck” 在本文中出现多次，但这个词在这里并不是污言秽语。）* 

不久前，有人在 [Reddit Rust 子论坛](https://www.reddit.com/r/rust/comments/5y4x9r/challenge_rusts_type_system_is_not_turing_complete/)上提出挑战：虽然每个人都喜欢说 Rust 的类型系统是图灵完备的，但实际上似乎还没有人给出确凿的证据。作为对那篇文章的回应，我以使用[Rust 实现 Smallfuck](https://github.com/sdleffler/tarpit-rs)（一种已知的图灵完备语言）的方式给出了一个证明，说明 Rust 的类型系统是图灵完备的。这篇文章将阐述 Smallfuck 的 Rust 实现的内部工作原理，以及这对 Rust 类型系统的意义。



那么什么是图灵完备性呢？图灵完备性是大多数编程语言的一个属性，它表明这些语言可以模拟通用图灵机。与之相关的概念是图灵等效。图灵等效语言可以模拟图灵机也可以被图灵机模拟——因此，如果你有任何两种图灵等效语言，则一定可以将使用一种语言编写的任何程序翻译成另一种语言编写的程序。大多数图灵完备的系统也被认为是图灵等效的。（[wiki](https://en.wikipedia.org/wiki/Turing_completeness#Formal_definitions)）



关于图灵完备性，有几件重要的事情需要注意。我们知道[停机问题](https://en.wikipedia.org/wiki/Halting_problem)， 如果一个系统是图灵完备的，那么也意味着停机问题不可解决。也就是说，如果你有一种图灵完备的语言，它可以模拟任何通用图灵机，那么它必须能够无限循环。这就是为什么知道 Rust 的类型系统是否是图灵完备的很有用——这意味着，如果你能够将图灵完备的语言编码到 Rust 的类型系统中，那么检查 Rust 程序以确保它的类型是否正确的过程必须是[不可判定的问题](https://en.wikipedia.org/wiki/Undecidable_problem)。类型检查器必须能够进行无限循环。



我们如何证明 Rust 类型系统是图灵完备的？最直接的方法（实际上我不知道其他方法）是在其中实现一种已知的图灵完备语言。如果你可以用一种语言实现图灵完备的语言，那么你可以清楚地在其中模拟任何通用图灵机，也就说明这种语言是图灵完备的。



## Smallfuck: 有用 & 无用

那么，什么是 [Smallfuck](https://esolangs.org/wiki/Smallfuck)？ Smallfuck 是一种极简的编程语言，当内存限制被解除时，它就是图灵完备的。我选择将它在 Rust 类型系统中实现而不是其他图灵完备的语言，就是因为它很简单。



实际上 Smallfuck 非常接近图灵机本身。 根据 Smallfuck 的原始规范声明，它是运行在内存有限的机器上的。然而，如果我们解除这个限制并允许它访问理论上无限的内存数组，那么 Smallfuck 就变成了图灵完备的。所以在这里，我们考虑一种具有无限内存的 Smallfuck 的变体。 本文中 Smallfuck 机器由无限的内存磁带组成，该磁带由包含位的“单元”以及指向该单元的指针组成。

```
                 Pointer |
                         v
...000001000111000001000001111...
```

Smallfuck 程序是由五个指令组成的字符串：

```
< | Pointer decrement
> | Pointer increment
* | Flip current bit
[ | If current bit is 0, jump past the matching ]; else, go to the next instruction
] | Jump back to the matching [ instruction
```

利用这几种指令就能够选择内存单元格并制作循环程序。这是一个简单的示例程序：

```
>*>*>*[*<]
```

这是一个非常简单且完全没用的程序（大多数 Smallfuck 程序都没啥用，这要归因于它完全没有任何类型的 I/O），它只是将指针所指位置的后三位设置为 1，然后使用循环将它们全部置回 0，最后指针停在它开始时候的位置。下面我们来看一下这个过程：

首先，以下是初始状态：

```
Instruction pointer
|               Memory pointer
v               v
>*>*>*[*<] | ...0...
```

第一条指令将指针向右移动。所有单元格默认为 0：

```
 v               v
>*>*>*[*<] | ...00...
```

下一条指令是“翻转当前位”指令，因此我们将指针处的位从 0 翻转到 1。

```
 v               v
>*>*>*[*<] | ...01...
```

这种情况发生了 3 次。我们跳过重复来到循环的开头：

```
      v            v
>*>*>*[*<] | ...0111...
```

现在我们处于循环的开始。 `[` 指令是说，“如果当前位为零，则跳转到匹配的 `]`；否则，转到下一条指令。” 当前指针所指是 1，所以我们转到下一条指令。

```
       v           v
>*>*>*[*<] | ...0111...
```

这会将当前位翻转回零；然后，我们将内存指针移回一个位置。

```
         v        v
>*>*>*[*<] | ...0110...
```

现在我们来到循环结束符`]`，无条件跳回到循环开始处。

```
      v           v
>*>*>*[*<] | ...0110...
```

现在我们再次分支。当前单元格为 0 吗？显然不为 0，然后我们继续：



```
       v          v
>*>*>*[*<] | ...0110...

        v         v
>*>*>*[*<] | ...0100...

         v       v
>*>*>*[*<] | ...0100...

      v          v
>*>*>*[*<] | ...0100...
```

在最后一次循环之后，我们结束了：

```
      v         v
>*>*>*[*<] | ...0000...
```

这正是我们开始的地方：所有单元格归零，并且指针位于其起始位置。



## Smallfuck 在 Rust 中的 Runtime

那么在 Rust 中这个简单的实现会是什么样子呢？我将首先介绍与我的类型级实现捆绑在一起的 Smallfuck 的运行时实现，以验证类型级和运行时实现是否一致。我们将 Smallfuck 程序存储为 AST，如下所示：





















